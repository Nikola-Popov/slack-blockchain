package io.slack.blockchain.services;

import org.junit.runner.RunWith;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class ProcessorServiceTest {
	// private static final String RESPONSE_URL = "responseUrl";
	//
	// @InjectMocks
	// private ProcessorService processorService;
	//
	// @Mock
	// private DialogResponder dialogResponderMock;
	//
	// @Mock
	// private DialogProcessorProvider dialogProcessorProviderMock;
	//
	// @Mock
	// private DialogContent<?> dialogContentMock;
	//
	// @Mock
	// private DialogProcessor dialogProcessorMock;
	//
	// @Mock
	// private ProcessingResult processingResultMock;
	//
	// @Mock
	// private DialogIdentityPayload dialogIdentityPayloadMock;
	//
	// @Before
	// public void setUp() {
	// when(dialogProcessorProviderMock.provide(dialogContentMock)).thenReturn(dialogProcessorMock);
	// when(dialogProcessorMock.process()).thenReturn(processingResultMock);
	// when(dialogContentMock.getDialogIdentityPayload()).thenReturn(dialogIdentityPayloadMock);
	// when(dialogIdentityPayloadMock.getResponseUrl()).thenReturn(RESPONSE_URL);
	// }
	//
	// @Test(expected = DialogResponderException.class)
	// public void testProcessDialogResponderRespondThrowsException() throws
	// Exception {
	// doThrow(DialogResponderException.class).when(dialogResponderMock).respond(RESPONSE_URL,
	// processingResultMock);
	//
	// processorService.process(dialogContentMock);
	// }
	//
	// @Test
	// public void testProcess() throws Exception {
	// processorService.process(dialogContentMock);
	//
	// verify(dialogResponderMock).respond(RESPONSE_URL, processingResultMock);
}
